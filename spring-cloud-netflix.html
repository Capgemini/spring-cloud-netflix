<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.1">
<title>Spring Cloud Netflix</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic|Noto+Serif:400,400italic,700,700italic|Droid+Sans+Mono:400">
<link rel="stylesheet" href="./asciidoctor.css">
</head>
<body class="article">
<div id="header">
<h1>Spring Cloud Netflix</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This project provides Netflix OSS integrations for Spring Boot apps through autoconfiguration
and binding to the Spring Environment and other Spring programming model idioms. With a few
simple annotations you can quickly enable and configure the common patterns inside your
application and build large distributed systems with battle-tested Netflix components. The
patterns provided include Service Discovery (Eureka), Circuit Breaker (Hystrix),
Intelligent Routing (Zuul) and Client Side Load Balancing (Ribbon).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_service_discovery_eureka_clients">Service Discovery: Eureka Clients</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Service Discovery is one of the key tenets of a microservice based architecture. Trying to hand configure each client or some form of convention can be very difficult to do and can be very brittle.  Eureka is the Netflix Service Discovery Server and Client.  The server can be configured and deployed to be highly available, with each server replicating state about the registered services to the others.</p>
</div>
<div class="paragraph">
<p>When clients register with Eureka, they provide eureka with meta-data about themselves such as host and port, health indicator URL, home page etc.  Eureka receives heartbeat messages from each instance belonging to a service.  If the heartbeat fails over a configurable timetable, the instance is normally removed from Eureka.</p>
</div>
<div class="paragraph">
<p>Example eureka client:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@Configuration
@ComponentScan
@EnableAutoConfiguration
@EnableEurekaClient
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello world";
    }

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>(i.e. utterly normal Spring Boot app). Configuration is required to locate the Eureka server. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8080/v2/</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default application name, virtual host and non-secure port are taken from the <code>Environment</code> is
<code>${spring.application.name}</code>, <code>${spring.application.name}.mydomain.net</code> and <code>${server.port}</code> respectively.</p>
</div>
<div class="paragraph">
<p><code>@EnableEurekaClient</code> makes the app into both a Eureka "instance"
(i.e. it registers itself) and a "client" (i.e. it can query the
registry to locate other services). The instance behaviour is driven
by <code>eureka.instance.*</code> configuration keys, but the defaults will be
fine if you ensure that your application has a
<code>spring.application.name</code> (this is the default for the Eureka service
ID, or VIP).</p>
</div>
<div class="paragraph">
<p>See {github-code}/spring-cloud-netflix-core/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java[EurekaInstanceConfigBean] and {github-code}/spring-cloud-netflix-core/src/main/java/org/springframework/cloud/netflix/eureka/EurekaClientConfigBean.java[EurekaClientConfigBean] for more details of the configurable options.</p>
</div>
<div class="sect2">
<h3 id="_why_is_it_so_slow_to_register_a_service">Why is it so Slow to Register a Service?</h3>
<div class="paragraph">
<p>Being an instance also involves a periodic heartbeat to the registry
(via the client&#8217;s <code>serviceUrl</code>) with default duration 30 seconds. A
service is not available for discovery by clients until the instance,
the server and the client all have the same metadata in their local
cache (so it could take 3 hearbeats). You can change the period using
<code>eureka.instance.leaseRenewalIntervalInSeconds</code> and this will speed up
the process of getting clients connected to other services. In
production it&#8217;s probably better to stick with the default because
there are some computations internally in the server that make
assumptions about the lease renewal period.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_service_discovery_eureka_server">Service Discovery: Eureka Server</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Example eureka server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@Configuration
@EnableAutoConfiguration
@EnableEurekaServer
public class Application {

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The server has a home page with a UI, and HTTP API endpoints per the
normal Eureka functionality under <code>/v2/*</code>.</p>
</div>
<div class="paragraph">
<p>Eureka background reading: see <a href="https://github.com/cfregly/fluxcapacitor/wiki/NetflixOSS-FAQ#eureka-service-discovery-load-balancer">flux capacitor</a> and <a href="https://groups.google.com/forum/?fromgroups#!topic/eureka_netflix/g3p2r7gHnN0">google group discussion</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_circuit_breaker_hystrix_clients">Circuit Breaker: Hystrix Clients</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Netflix has created a library called <a href="https://github.com/Netflix/Hystrix">Hystrix</a> that implements the <a href="http://martinfowler.com/bliki/CircuitBreaker.html">circuit breaker pattern</a>.  In a microservice architecture it is common to have multiple layers of service calls.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="HystrixGraph.png" alt="HystrixGraph">
</div>
<div class="title">Figure 1. Microservice Graph</div>
</div>
<div class="paragraph">
<p>A service failure in the lower level of services can cause cascading failure all the way up to the user.  When calls to a particular service reach a certain threshold (20 failures in 5 seconds is the default in Hystrix), the circuit opens and the call is not made.  In cases of error and an open circuit a fallback can be provided by the developer.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="HystrixFallback.png" alt="HystrixFallback">
</div>
<div class="title">Figure 2. Hystrix fallback prevents cascading failures</div>
</div>
<div class="paragraph">
<p>Having an open circuit stops cascading failures and allows overwhelmed or failing services time to heal.  The fallback can be another Hystrix protected call, static data or a sane empty value.  Fallbacks may be chained so the first fallback makes some other business call which in turn falls back to static data.</p>
</div>
<div class="paragraph">
<p>Example boot app:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@Configuration
@EnableAutoConfiguration
@EnableHystrix
public class Application {

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}

@Component
public class StoreIntegration {

    @HystrixCommand(fallbackMethod = "defaultStores")
    public Object getStores(Map&lt;String, Object&gt; parameters) {
        //do stuff that might fail
    }

    public Object defaultStores(Map&lt;String, Object&gt; parameters) {
        return /* something useful */;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@HystrixCommand</code> is provided by a Netflix contrib library called
"javanica". Spring Cloud automatically wraps Spring beans with that
annotation in a proxy that is connected to the Hystrix circuit
breaker. The circuit breaker calculates when to open and close the
circuit, and what to do in case of a failure.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_circuit_breaker_hystrix_dashboard">Circuit Breaker: Hystrix Dashboard</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One of the main benefits of Hystrix is the set of metrics it gathers about each HystrixCommand.  The Hystrix Dashboard displays the health of each circuit breaker in an efficient manner.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Hystrix.png" alt="Hystrix">
</div>
<div class="title">Figure 3. Hystrix Dashboard</div>
</div>
<div class="paragraph">
<p>To run the Hystrix Dashboard annotate your Spring Boot main class with <code>@EnableHystrixDashboard</code>.  You then visit <code>/hystrix/index.html</code> and point the dashboard to an individual instances <code>/hystrix.stream</code> endpoint in a Hystrix client application.</p>
</div>
<div class="sect2">
<h3 id="_turbine">Turbine</h3>
<div class="paragraph">
<p>Looking at an individual instances Hystrix data is not very useful in terms of the overall health of the system.  <a href="https://github.com/Netflix/Turbine">Turbine</a> is an application that aggregates all of the relevant <code>/hystrix.stream</code> endpoints into a combined <code>/turbine.stream</code> for use in the Hystrix Dashboard.  Individual instances are located via Eureka.  Running Turbine is as simple as annotating your main class with the <code>@EnableTurbine</code> annotation.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_declarative_rest_client_feign">Declarative REST Client: Feign</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://github.com/Netflix/feign">Feign</a> is a declarative web service client.  It makes writing web service clients easier.  To use Feign create an interface and annotate it.  It has pluggable annotation support including Feign annotations and JAX-RS annotations. Feign also supports pluggable encoders and decoders.  Spring Cloud adds support for Spring MVC annotations and for using the same <code>HttpMessageConverters</code> used by default in Spring Web.  Spring Cloud integrates Ribbon and Eureka to provide a load balanced http client when using Feign.</p>
</div>
<div class="paragraph">
<p>Example spring boot app</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@Configuration
@ComponentScan
@EnableAutoConfiguration
@EnableEurekaClient
public class Application extends FeignConfigurer {
    @Bean
    public StoreClient storeClient() {
        //loadBalance plugs Feign into ribbon.  feign() works without load balancing.
        return loadBalance(StoreClient.class, "http://stores");
    }

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>StoreClient.java</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>public interface StoreClient {
    @RequestMapping(method = RequestMethod.GET, value = "/stores")
    Stores getStores();

    @RequestMapping(method = RequestMethod.POST, value = "/stores/{storeId}", consumes = "application/json")
    Store update(@PathParameter("storeId") Long storeId, Store store);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_client_side_load_balancer_ribbon">Client Side Load Balancer: Ribbon</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Usage of <code>LoadBalancerClient</code> directly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>public class MyClass {
    @Autowired
    private LoadBalancerClient loadBalancer;

    public void doStuff() {
        ServiceInstance instance = loadBalancer.choose("stores");
        URI storesUri = URI.create(String.format("http://%s:%s", instance.getHost(), instance.getPort()));
        // ... do something with the URI
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Indirect usage via <code>RestTemplate</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>public class MyClass {
    @Autowired
    private RestTemplate restTemplate;

    public String doOtherStuff() {
        String results = restTemplate.getForObject("http://stores/stores", String.class);
        return results;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_external_configuration_archaius">External Configuration: Archaius</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://github.com/Netflix/archaius">Archaius</a> is the Netflix client side configuration library.  It is the library used by all of the Netflix OSS components for configuration.  Archaius is an extension of the <a href="http://commons.apache.org/proper/commons-configuration">Apache Commons Configuration</a> project.  It allows updates to configuration by either polling a source for changes or for a source to push changes to the client.  Archaius uses Dynamic&lt;Type&gt;Property classes as handles to properties.</p>
</div>
<div class="listingblock">
<div class="title">Archaius Example</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class ArchaiusTest {
    DynamicStringProperty myprop = DynamicPropertyFactory
            .getInstance()
            .getStringProperty("my.prop");

    void doSomething() {
        OtherClass.someMethod(myprop.get());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Archaius has its own set of configuration files and loading priorities.  Spring applications should generally not use Archaius directly., but the need to configure the Netflix tools natively remains.  Spring Cloud has a Spring Environment Bridge so Archaius can read properties from the Spring Environment.  This allows Spring Boot projects to use the normal configuration toolchain, while allowing them to configure the Netflix tools, for the most part, as documented.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_router_and_filter_zuul">Router and Filter: Zuul</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Routing in an integral part of a microservice architecture.  For example, <code>/</code> may be mapped to your web application, <code>/api/users</code> is mapped to the user service and <code>/api/shop</code> is mapped to the shop service.  <a href="https://github.com/Netflix/zuul">Zuul</a> is a JVM based router and server side load balancer by Netflix.</p>
</div>
<div class="paragraph">
<p><a href="http://www.slideshare.net/MikeyCohen1/edge-architecture-ieee-international-conference-on-cloud-engineering-32240146/27">Netflix uses Zuul</a> for the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Authentication</p>
</li>
<li>
<p>Insights</p>
</li>
<li>
<p>Stress Testing</p>
</li>
<li>
<p>Canary Testing</p>
</li>
<li>
<p>Dynamic Routing</p>
</li>
<li>
<p>Service Migration</p>
</li>
<li>
<p>Load Shedding</p>
</li>
<li>
<p>Security</p>
</li>
<li>
<p>Static Response handling</p>
</li>
<li>
<p>Active/Active traffic management</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Zuul&#8217;s rule engine allows rules and filters to be written in essentially any JVM language, with built in support for Java and Groovy.</p>
</div>
<div class="paragraph">
<p>Spring Cloud has created an embedded Zuul proxy to ease the development of a very common use case where a UI application wants to proxy calls to one or more back end services.  To enable it, annotate a Spring Boot main class with <code>@EnableZuulProxy</code>.  This forwards local calls to <code>/proxy/*</code> to the appropriate service.  The proxy uses Ribbon to locate an instance to forward to via Eureka.  Forwarding to the service is protected by a Hystrix circuit breaker.  Rules are configured via the Spring environment.  The Config Server is an ideal place for the Zuul configuration.  Configuration rules look like the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>zuul.proxy.route.users: /users</pre>
</div>
</div>
<div class="paragraph">
<p>This means that http calls to /proxy/users to the users service.  This proxy configuration is useful for services that host a user interface to proxy to the backend services it requires.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2014-10-03 11:08:49 BST
</div>
</div>
</body>
</html>